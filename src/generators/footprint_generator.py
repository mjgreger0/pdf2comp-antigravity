from typing import List, Dict, Tuple, Optional
import math
from datetime import datetime
from src.models.data_models import Package

class FootprintGenerator:
    """Generates KiCAD footprint files (.kicad_mod) from package data."""

    def __init__(self):
        # IPC-7351B Nominal Density (simplified)
        self.toe_fillet = 0.35  # mm
        self.heel_fillet = 0.35 # mm
        self.side_fillet = 0.05 # mm
        self.courtyard_excess = 0.25 # mm
        self.fabrication_tolerance = 0.05 # mm
        self.placement_tolerance = 0.05 # mm

    def generate_footprint(self, package: Package) -> str:
        """
        Generates the S-expression string for a KiCAD footprint.
        
        Args:
            package: The package metadata including dimensions.
            
        Returns:
            String containing the .kicad_mod content.
        """
        name = package.name
        dims = package.dimensions or {}
        
        # Header
        content = [
            '(kicad_mod (version 20211014) (generator kicad_footprint_editor)',
            f'  (footprint "{name}" (layer "F.Cu")',
            '    (tedit 0)',
            f'    (descr "{package.package_type} generated by MinerU-KiCAD")',
            f'    (attr smd)',
            f'    (fp_text reference "REF**" (at 0 -{dims.get("body_width", 5)/2 + 2}) (layer "F.SilkS")',
            '      (effects (font (size 1 1) (thickness 0.15)))',
            '    )',
            f'    (fp_text value "{name}" (at 0 {dims.get("body_width", 5)/2 + 2}) (layer "F.Fab")',
            '      (effects (font (size 1 1) (thickness 0.15)))',
            '    )',
        ]

        # Determine package type and generate pads
        pkg_type = (package.package_type or "").lower()
        
        if "qfn" in pkg_type or "qfp" in pkg_type:
            content.extend(self._generate_quad_pads(dims))
        elif "soic" in pkg_type or "sop" in pkg_type or "sot" in pkg_type:
            content.extend(self._generate_dual_row_pads(dims))
        else:
            # Fallback or generic handling
            content.extend(self._generate_dual_row_pads(dims))

        # Add Courtyard
        content.extend(self._generate_courtyard(dims))

        content.append('  )') # End footprint
        content.append(')')   # End file
        
        return '\n'.join(content)

    def _calculate_pad_dims(self, lead_len: float, lead_width: float, is_exposed: bool = False) -> Tuple[float, float]:
        """Calculates pad dimensions based on IPC-7351B formulas."""
        if is_exposed:
            # For exposed pads, we usually just match the size or reduce slightly for paste
            return lead_len, lead_width
            
        # Z_max = L_max + 2*J_T + sqrt(Tol_L^2 + Tol_F^2 + Tol_P^2) ... simplified
        # Pad Length = Lead Length + Toe + Heel
        pad_len = lead_len + self.toe_fillet + self.heel_fillet
        
        # Pad Width = Lead Width + 2 * Side
        pad_width = lead_width + (2 * self.side_fillet)
        
        return pad_len, pad_width

    def _generate_dual_row_pads(self, dims: Dict[str, float]) -> List[str]:
        lines = []
        
        # Extract dimensions with defaults
        body_w = dims.get("body_width", 4.0)
        body_l = dims.get("body_length", 5.0)
        pitch = dims.get("pitch", 1.27)
        lead_w = dims.get("lead_width", 0.4)
        lead_l = dims.get("lead_length", 0.8) # Foot length
        num_pins = int(dims.get("pin_count", 8))
        
        pad_len, pad_width = self._calculate_pad_dims(lead_l, lead_w)
        
        # Calculate X position (center of pad)
        # Span = Body Width + 2 * Lead Length (approx)
        # Real IPC calc uses min/max, here we simplify
        span = body_w + (2 * lead_l)
        x_pos = (span / 2) + (self.toe_fillet - self.heel_fillet)/2 # Adjust for fillets
        
        pins_per_side = num_pins // 2
        total_h = (pins_per_side - 1) * pitch
        start_y = -(total_h / 2)
        
        for i in range(pins_per_side):
            y = start_y + (i * pitch)
            
            # Left side (Pins 1 to N/2)
            pin_num = i + 1
            lines.append(
                f'    (pad "{pin_num}" smd rect (at {-x_pos} {y}) (size {pad_len} {pad_width}) (layers "F.Cu" "F.Paste" "F.Mask"))'
            )
            
            # Right side (Pins N to N/2 + 1)
            pin_num_right = num_pins - i
            lines.append(
                f'    (pad "{pin_num_right}" smd rect (at {x_pos} {y}) (size {pad_len} {pad_width}) (layers "F.Cu" "F.Paste" "F.Mask"))'
            )
            
        # Draw Body Outline (Silk)
        lines.append(
            f'    (fp_line (start {-body_w/2} {-body_l/2}) (end {body_w/2} {-body_l/2}) (stroke (width 0.12) (type solid)) (layer "F.SilkS"))'
        )
        lines.append(
            f'    (fp_line (start {-body_w/2} {body_l/2}) (end {body_w/2} {body_l/2}) (stroke (width 0.12) (type solid)) (layer "F.SilkS"))'
        )
        
        return lines

    def _generate_quad_pads(self, dims: Dict[str, float]) -> List[str]:
        # Simplified Quad implementation
        lines = []
        body_w = dims.get("body_width", 5.0)
        body_l = dims.get("body_length", 5.0)
        pitch = dims.get("pitch", 0.5)
        lead_w = dims.get("lead_width", 0.25)
        lead_l = dims.get("lead_length", 0.4)
        num_pins = int(dims.get("pin_count", 32))
        
        pad_len, pad_width = self._calculate_pad_dims(lead_l, lead_w)
        
        pins_per_side = num_pins // 4
        
        # Offsets
        offset_w = (body_w / 2) + (lead_l / 2) # Approx
        offset_l = (body_l / 2) + (lead_l / 2)
        
        # Helper to generate a row
        def gen_row(start_pin, count, x_fixed, y_start, x_step, y_step, w, h, angle):
            for i in range(count):
                x = x_fixed + (i * x_step)
                y = y_start + (i * y_step)
                lines.append(
                    f'    (pad "{start_pin + i}" smd rect (at {x} {y} {angle}) (size {w} {h}) (layers "F.Cu" "F.Paste" "F.Mask"))'
                )

        span = (pins_per_side - 1) * pitch
        half_span = span / 2
        
        # Left (1 to N/4)
        gen_row(1, pins_per_side, -offset_w, -half_span, 0, pitch, pad_len, pad_width, 0)
        
        # Bottom (N/4+1 to N/2)
        gen_row(pins_per_side + 1, pins_per_side, -half_span, offset_l, pitch, 0, pad_width, pad_len, 0)
        
        # Right (N/2+1 to 3N/4) - Order is usually bottom-up or top-down depending on numbering.
        # Standard QFN is CCW.
        # Right side goes Bottom to Top? No, usually Top to Bottom is standard for dual, but Quad is CCW.
        # 1..N Left (Top-Down)
        # N..2N Bottom (Left-Right)
        # 2N..3N Right (Bottom-Top)
        # 3N..4N Top (Right-Left)
        
        # Let's assume CCW starting Top-Left
        
        # Re-doing logic for CCW standard
        # Left: -X, Y varies
        # Bottom: X varies, +Y
        # Right: +X, Y varies
        # Top: X varies, -Y
        
        # Left (Top to Bottom)
        gen_row(1, pins_per_side, -offset_w, -half_span, 0, pitch, pad_len, pad_width, 0)
        
        # Bottom (Left to Right)
        gen_row(pins_per_side + 1, pins_per_side, -half_span, offset_l, pitch, 0, pad_width, pad_len, 0)
        
        # Right (Bottom to Top)
        # Note: KiCAD rotation 0 means width is X.
        # For Right side, we want pad_len to be width-wise.
        # Y goes from +half_span to -half_span
        for i in range(pins_per_side):
            pin = pins_per_side * 2 + 1 + i
            y = half_span - (i * pitch)
            lines.append(
                f'    (pad "{pin}" smd rect (at {offset_w} {y}) (size {pad_len} {pad_width}) (layers "F.Cu" "F.Paste" "F.Mask"))'
            )
            
        # Top (Right to Left)
        for i in range(pins_per_side):
            pin = pins_per_side * 3 + 1 + i
            x = half_span - (i * pitch)
            lines.append(
                f'    (pad "{pin}" smd rect (at {x} {-offset_l}) (size {pad_width} {pad_len}) (layers "F.Cu" "F.Paste" "F.Mask"))'
            )

        # Body Outline
        lines.append(
            f'    (fp_line (start {-body_w/2} {-body_l/2}) (end {body_w/2} {-body_l/2}) (stroke (width 0.12) (type solid)) (layer "F.SilkS"))'
        )
        lines.append(
            f'    (fp_line (start {body_w/2} {-body_l/2}) (end {body_w/2} {body_l/2}) (stroke (width 0.12) (type solid)) (layer "F.SilkS"))'
        )
        lines.append(
            f'    (fp_line (start {body_w/2} {body_l/2}) (end {-body_w/2} {body_l/2}) (stroke (width 0.12) (type solid)) (layer "F.SilkS"))'
        )
        lines.append(
            f'    (fp_line (start {-body_w/2} {body_l/2}) (end {-body_w/2} {-body_l/2}) (stroke (width 0.12) (type solid)) (layer "F.SilkS"))'
        )

        return lines

    def _generate_courtyard(self, dims: Dict[str, float]) -> List[str]:
        # Simple bounding box + excess
        body_w = dims.get("body_width", 5.0)
        body_l = dims.get("body_length", 5.0)
        
        # Assume max span includes pads
        # This is a rough approximation
        w = body_w + 2.0 # Arbitrary padding if lead_len unknown
        l = body_l + 2.0
        
        lines = [
            f'    (fp_rect (start {-w/2} {-l/2}) (end {w/2} {l/2}) (stroke (width 0.05) (type default)) (layer "F.CrtYd"))'
        ]
        return lines
